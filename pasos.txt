1. Tokenizar con un split especial divide por espacios pero estos espacios no los guarda si no que los ignora
tambien divide por los simbolos por ejemplo | < > << >> $(no sabemos si dividirlo o no) - (maybe dividirlo aqui)

2. Leemos cada token le damos unos valores por ejemplo le decimos si es un paramet

3. Aqui buscamos errores, no podemos poner un "<>", no podemos mezclar símbolos que dividan,
todos los símbolos tienen que tener una palabra antes y otra después
	?No hace nada especial?		comando < archivo ==> comando > archivo


4. Parsear los tokens para comprobar que estan bien.

5. expander

6. ejecutar


Deberá implementar los built-ins:
◦ echo con la opción -n.
◦ cd solo con una ruta relativa o absoluta.
◦ pwd sin opciones.
◦ export sin opciones.
◦ unset sin opciones.
◦ env sin opciones o argumentos.
◦ exit sin opciones.
hay que hacer estas funciones


✅ cd → Cambia el directorio de trabajo. No se puede ejecutar con execve().
✅ exit → Cierra el shell. Debe manejarse antes de llegar al executor.
✅ export → Modifica variables de entorno. No se ejecuta como un proceso hijo.
✅ unset → Elimina variables de entorno.
✅ echo → Maneja -n de forma especial.
✅ pwd → No usa execve(), sino getcwd().


Si encontramos comillas si cerrar sera un error 
Claro esto tiene un punto y es que por ejemplo echo "'hola" si es valido ya que la comilla simple esta dentro de las dobles
Si encontramos un \ o un ; es un error (fuera de las comillas)

Hacer las funciones built in


El tester hace primero los builtin luego las pipes redirects y extras