1. Tokenizar con un split especial divide por espacios pero estos espacios no los guarda si no que los ignora
tambien divide por los simbolos por ejemplo | < > << >> $(no sabemos si dividirlo o no) - (maybe dividirlo aqui)

2. Leemos cada token le damos unos valores por ejemplo le decimos si es un paramet

3. Aqui buscamos errores, no podemos poner un "<>", no podemos mezclar símbolos que dividan,
todos los símbolos tienen que tener una palabra antes y otra después
	?No hace nada especial?		comando < archivo ==> comando > archivo


4. Parsear los tokens para comprobar que estan bien.

5. expander

6. ejecutar


Deberá implementar los built-ins:
◦ echo con la opción -n.
◦ cd solo con una ruta relativa o absoluta.
◦ pwd sin opciones.
◦ export sin opciones.
◦ unset sin opciones.
◦ env sin opciones o argumentos.
◦ exit sin opciones.
hay que hacer estas funciones


✅ cd → Cambia el directorio de trabajo. No se puede ejecutar con execve().
✅ exit → Cierra el shell. Debe manejarse antes de llegar al executor.
✅ export → Modifica variables de entorno. No se ejecuta como un proceso hijo.
✅ unset → Elimina variables de entorno.
✅ echo → Maneja -n de forma especial.
✅ pwd → No usa execve(), sino getcwd().


Si encontramos comillas si cerrar sera un error 
Claro esto tiene un punto y es que por ejemplo echo "'hola" si es valido ya que la comilla simple esta dentro de las dobles
Si encontramos un \ o un ; es un error (fuera de las comillas)

Hacer las funciones built in


El tester hace primero los builtin luego las pipes redirects y extras


HABLANDO COMO UN IGNORANTE OWO

En /usr/bin esta el ejecutable de los comandos si no 
encontramos el comando en /usr/bin buscamos en /bin
si no encontramos en ninguno de los dos es un error
ya que el comando no existe

Pasos siguientes que podemos seguir crear otra estructura podemos crear una que e llame minishel que sea como global que tenga los tokens el exit code y lo que necesitemos
y que se vaya pasando por parametros a las funciones que necesiten usarlo

Después podemos hacer otra estrucutra que sea t_command. Que tenga los tokens ya parseados para directamente ejecutarlos sin problema

VER EXECUTE_TRY PARA MAS INFORMACION :D



VER BUILTINT UNSET PARA MAS INFORMACION :D

PASOS SIGUIENTES REALMENTE NOS QUEDA REDIRECCIONES, PIPES Y EXITS (CODE Y MEMORIA)

YO PROPONGO LO SIGUIENTE 

1. Hacer las redirecciones
2. Hacer los pipes
3. Hacer el exit CODE
4. Revisar los leaks
5. Refactorizar este puede ir despues del 3 o 4 en verdad pero creo que aqui sera mejor 
ya que si refactorizamos antes de hacer el exit code y hay un error en el exit code no sabremos
 si es por el exit code o por el refactor
 6. Testing
 7. Entrega (emojis de fiesta) :D


Soon:
- Las comillas fallan otra vez, se muestran por pantalla.
- Arreglar el error que ocurre cuando se ejecuta un solo comando externo
	"Minishell> ls -l
	(El comando se ejecuta bien y se muestra)
	Saliendo de minishell"
	Cuando vuelve al bucle peta, por alguna señal y coso en la memoria
- Crear la estructura de "free" y llamarla con cada null check y malloc ?
- Crear la estrucutra del exit code
	Meterlo en el t_minishell
	Investigar dónde se modifica
	Añadirlo al $?
	"c2r2s2% hola
	zsh: command not found: hola
	c2r2s2% echo "$?"
	127
	c2r2s2% echo hola
	hola
	c2r2s2% echo "$?"
	0"
	Error en quotes = 2?



Racasado
	- Ser padre de los builtin
Droura
	- Revisar comillas interiores
	echo hello'world'
	echo hello""world
	- Leaks de locos tío
	- El export no necesita quitar comillas ya.


- Export check marks/quotes
	>export AZUL="MAR"  ===   export AZUL=MAR<
		export z=z	 ==> export z=z		arg_count = 2
		export z="z" ==> export z= z	arg_count = 3

- Spaces in echo must been check
- Rerefactor the commands to follow the norme
- Check the leaks
- Check the exit code
- Minishell> echo "hola $?" '$?'
	hola 127 127


Racasado: "Y si hacemos que los tokens que están dentro de las mismas comillas no se separen?"


Exit codes
https://www.geeksforgeeks.org/exit-codes-in-c-c-with-examples/

void exit(int return_code)

Note: It is also to taken into consideration that an exit code with a value greater than 255 returns an exit code modulo 256.
For Example: If we execute a statement exit(9999) then it will execute exit(15) as 9999%256 = 15.
Some of the Exit Codes are: 
 
    exit(1): It indicates abnormal termination of a program perhaps as a result a minor problem in the code.
    exit(2): It is similar to exit(1) but is displayed when the error occurred is a major one. This statement is rarely seen.
    exit(127): It indicates command not found.
    exit(132): It indicates that a program was aborted (received SIGILL), perhaps as a result of illegal instruction or that the binary is probably corrupt.
    exit(133): It indicates that a program was aborted (received SIGTRAP), perhaps as a result of dividing an integer by zero.
    exit(134): It indicates that a program was aborted (received SIGABRT), perhaps as a result of a failed assertion.
    exit(136): It indicates that a program was aborted (received SIGFPE), perhaps as a result of floating point exception or integer overflow.
    exit(137): It indicates that a program took up too much memory.
    exit(138): It indicates that a program was aborted (received SIGBUS), perhaps as a result of unaligned memory access.
    exit(139): It indicates Segmentation Fault which means that the program was trying to access a memory location not allocated to it. This mostly occurs while using pointers or trying to access an out-of-bounds array index.
    exit(158/152): It indicates that a program was aborted (received SIGXCPU), perhaps as a result of CPU time limit exceeded.
    exit(159/153): It indicates that a program was aborted (received SIGXFSZ), perhaps as a result of File size limit exceeded.
