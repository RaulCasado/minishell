1. Tokenizar con un split especial divide por espacios pero estos espacios no los guarda si no que los ignora
tambien divide por los simbolos por ejemplo | < > << >> $(no sabemos si dividirlo o no) - (maybe dividirlo aqui)

2. Leemos cada token le damos unos valores por ejemplo le decimos si es un paramet

3. Aqui buscamos errores, no podemos poner un "<>", no podemos mezclar símbolos que dividan,
todos los símbolos tienen que tener una palabra antes y otra después
	?No hace nada especial?		comando < archivo ==> comando > archivo


4. Parsear los tokens para comprobar que estan bien.

5. expander

6. ejecutar


Deberá implementar los built-ins:
◦ echo con la opción -n.
◦ cd solo con una ruta relativa o absoluta.
◦ pwd sin opciones.
◦ export sin opciones.
◦ unset sin opciones.
◦ env sin opciones o argumentos.
◦ exit sin opciones.
hay que hacer estas funciones


✅ cd → Cambia el directorio de trabajo. No se puede ejecutar con execve().
✅ exit → Cierra el shell. Debe manejarse antes de llegar al executor.
✅ export → Modifica variables de entorno. No se ejecuta como un proceso hijo.
✅ unset → Elimina variables de entorno.
✅ echo → Maneja -n de forma especial.
✅ pwd → No usa execve(), sino getcwd().


Si encontramos comillas si cerrar sera un error 
Claro esto tiene un punto y es que por ejemplo echo "'hola" si es valido ya que la comilla simple esta dentro de las dobles
Si encontramos un \ o un ; es un error (fuera de las comillas)

Hacer las funciones built in


El tester hace primero los builtin luego las pipes redirects y extras


HABLANDO COMO UN IGNORANTE OWO

En /usr/bin esta el ejecutable de los comandos si no 
encontramos el comando en /usr/bin buscamos en /bin
si no encontramos en ninguno de los dos es un error
ya que el comando no existe

Pasos siguientes que podemos seguir crear otra estructura podemos crear una que e llame minishel que sea como global que tenga los tokens el exit code y lo que necesitemos
y que se vaya pasando por parametros a las funciones que necesiten usarlo

Después podemos hacer otra estrucutra que sea t_command. Que tenga los tokens ya parseados para directamente ejecutarlos sin problema

VER EXECUTE_TRY PARA MAS INFORMACION :D



VER BUILTINT UNSET PARA MAS INFORMACION :D

PASOS SIGUIENTES REALMENTE NOS QUEDA REDIRECCIONES, PIPES Y EXITS (CODE Y MEMORIA)

YO PROPONGO LO SIGUIENTE 

1. Hacer las redirecciones
2. Hacer los pipes
3. Hacer el exit CODE
4. Revisar los leaks
5. Refactorizar este puede ir despues del 3 o 4 en verdad pero creo que aqui sera mejor 
ya que si refactorizamos antes de hacer el exit code y hay un error en el exit code no sabremos
 si es por el exit code o por el refactor
 6. Testing
 7. Entrega (emojis de fiesta) :D


Soon:
- Las comillas fallan otra vez, se muestran por pantalla.
- Arreglar el error que ocurre cuando se ejecuta un solo comando externo
	"Minishell> ls -l
	(El comando se ejecuta bien y se muestra)
	Saliendo de minishell"
	Cuando vuelve al bucle peta, por alguna señal y coso en la memoria
- Crear la estructura de "free" y llamarla con cada null check y malloc ?
- Crear la estrucutra del exit code
	Meterlo en el t_minishell
	Investigar dónde se modifica
	Añadirlo al $?
	"c2r2s2% hola
	zsh: command not found: hola
	c2r2s2% echo "$?"
	127
	c2r2s2% echo hola
	hola
	c2r2s2% echo "$?"
	0"
	Error en quotes = 2?



Racasado

Droura


- Export check marks/quotes
	>export AZUL="MAR"  ===   export AZUL=MAR<
		export z=z	 ==> export z=z		arg_count = 2
		export z="z" ==> export z= z	arg_count = 3

- Spaces in echo must been check
- Rerefactor the commands to follow the norme
- Check the leaks
- Check the exit code
- Minishell> echo "hola $?" '$?'
	hola 127 127


Racasado: "Y si hacemos que los tokens que están dentro de las mismas comillas no se separen?"
Printing tokens:
0: echo
1: $USER
2: "$USER
3: $?"
4: '$USER'


Printing tokens:
0: echo
1: $USER
2: "$USER
3: 
4: '$USER'